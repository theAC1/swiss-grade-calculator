import { GradingConfig, AlgorithmType, Student, Stats, Language } from './types';

export const TRANSLATIONS = {
  en: {
    maxPossiblePoints: "Max Possible Points",
    pointsFor6: "Points for Grade 6",
    pointsFor4: "Points for Grade 4",
    minGrade: "Min Grade",
    rounding: "Rounding",
    algorithm: "Grading Curve",
    linear: "Linear",
    linearDesc: "Standard scale (equal distribution)",
    nice: "Nice (Generous)",
    niceDesc: "Easier to get good grades (Concave)",
    hard: "Hard (Strict)",
    hardDesc: "Harder to get good grades (Convex)",
    students: "Students",
    addStudent: "Add Student",
    export: "Export CSV",
    import: "Import CSV",
    gradeScale: "Grade Scale",
    gradeDistribution: "Grade Distribution",
    gradingCurve: "Grading Curve",
    stats: {
      avg: "Average",
      median: "Median",
      passRate: "Pass Rate",
      stdDev: "Std Dev"
    },
    actions: "Actions",
    name: "Name",
    points: "Points",
    grade: "Grade",
    reportView: "Report View",
    editView: "Edit / Setup",
    classroomMode: "Classroom Mode",
    generatedBy: "Generated by Swiss Grade Calculator"
  },
  de: {
    maxPossiblePoints: "Max. Punktzahl (Prüfung)",
    pointsFor6: "Punkte für Note 6",
    pointsFor4: "Punkte für Note 4",
    minGrade: "Tiefste Note",
    rounding: "Rundung",
    algorithm: "Notenskala-Typ",
    linear: "Linear",
    linearDesc: "Gleichmässige Verteilung",
    nice: "Grosszügig",
    niceDesc: "Schneller gute Noten (Konkav)",
    hard: "Streng",
    hardDesc: "Schwerer gute Noten zu erreichen (Konvex)",
    students: "Schülerliste",
    addStudent: "Schüler hinzufügen",
    export: "CSV Export",
    import: "CSV Import",
    gradeScale: "Notenspiegel",
    gradeDistribution: "Notenverteilung",
    gradingCurve: "Notenskala-Kurve",
    stats: {
      avg: "Durchschnitt",
      median: "Median",
      passRate: "Genügend",
      stdDev: "Std. Abw."
    },
    actions: "Aktionen",
    name: "Name",
    points: "Punkte",
    grade: "Note",
    reportView: "Report Ansicht",
    editView: "Bearbeiten",
    classroomMode: "Präsentationsmodus",
    generatedBy: "Erstellt mit Notenrechner"
  },
  fr: {
    maxPossiblePoints: "Points Max. (Examen)",
    pointsFor6: "Points pour Note 6",
    pointsFor4: "Points pour Note 4",
    minGrade: "Note Min.",
    rounding: "Arrondi",
    algorithm: "Type d'échelle",
    linear: "Linéaire",
    linearDesc: "Distribution égale",
    nice: "Généreux",
    niceDesc: "Plus facile d'avoir de bonnes notes",
    hard: "Sévère",
    hardDesc: "Plus difficile d'avoir de bonnes notes",
    students: "Étudiants",
    addStudent: "Ajouter",
    export: "Exporter CSV",
    import: "Importer CSV",
    gradeScale: "Barème",
    gradeDistribution: "Distribution des notes",
    gradingCurve: "Courbe de notation",
    stats: {
      avg: "Moyenne",
      median: "Médiane",
      passRate: "Réussite",
      stdDev: "Écart-type"
    },
    actions: "Actions",
    name: "Nom",
    points: "Points",
    grade: "Note",
    reportView: "Vue Rapport",
    editView: "Éditer",
    classroomMode: "Mode Présentation",
    generatedBy: "Généré par Calculateur de Notes"
  }
};

export const roundGrade = (value: number, step: number): number => {
  const inv = 1.0 / step;
  return Math.round(value * inv) / inv;
};

// Calculate exponent based on algorithm
const getExponent = (algo: AlgorithmType): number => {
  switch (algo) {
    case AlgorithmType.NICE: return 0.80; // Concave (Root-like)
    case AlgorithmType.HARD: return 1.25; // Convex (Exp-like)
    default: return 1.0; // Linear
  }
};

export const calculateRawGrade = (points: number, config: GradingConfig): number => {
  // Clamp points to max possible for safety
  const p = Math.max(0, Math.min(points, config.maxPossiblePoints));
  
  // If points >= Points for 6, return Max Grade
  if (p >= config.pointsFor6) {
    return config.gradeMax;
  }

  const exponent = getExponent(config.algorithm);
  const passGrade = 4.0;
  
  if (p < config.pointsFor4) {
    // Segment 1: 0 to PointsFor4 maps to GradeMin to 4.0
    // Normalized ratio (0 to 1)
    const ratio = p / Math.max(0.1, config.pointsFor4);
    // Apply curve
    const curvedRatio = Math.pow(ratio, exponent); // If exp < 1 (Nice), this boosts low scores.
    // Scale
    return config.gradeMin + (curvedRatio * (passGrade - config.gradeMin));
  } else {
    // Segment 2: PointsFor4 to PointsFor6 maps to 4.0 to GradeMax
    const rangePoints = config.pointsFor6 - config.pointsFor4;
    const pointsAbove = p - config.pointsFor4;
    const ratio = pointsAbove / Math.max(0.1, rangePoints);
    
    // For the upper segment:
    // "Nice" (Concave): curve should bulge up. x^0.8 does that.
    // "Hard" (Convex): curve should sag down. x^1.2 does that.
    const curvedRatio = Math.pow(ratio, exponent);
    
    return passGrade + (curvedRatio * (config.gradeMax - passGrade));
  }
};

export const calculateGrade = (points: number, config: GradingConfig): number => {
  const raw = calculateRawGrade(points, config);
  // Ensure we don't exceed max grade or go below min
  const clamped = Math.max(config.gradeMin, Math.min(config.gradeMax, raw));
  return roundGrade(clamped, config.roundingStep);
};

export const getMinPointsForGrade = (targetRawGrade: number, config: GradingConfig): number => {
  const exponent = getExponent(config.algorithm);
  const passGrade = 4.0;
  
  if (targetRawGrade <= config.gradeMin) return 0;
  if (targetRawGrade >= config.gradeMax) return config.pointsFor6;

  if (targetRawGrade < passGrade) {
    // Inverse of Segment 1
    // Grade = Min + (Ratio^Exp * (Pass - Min))
    // Ratio^Exp = (Grade - Min) / (Pass - Min)
    // Ratio = ((Grade - Min) / (Pass - Min)) ^ (1/Exp)
    const gradeRange = passGrade - config.gradeMin;
    const ratio = Math.pow((targetRawGrade - config.gradeMin) / gradeRange, 1 / exponent);
    return ratio * config.pointsFor4;
  } else {
    // Inverse of Segment 2
    // Grade = Pass + (Ratio^Exp * (Max - Pass))
    // Ratio = ((Grade - Pass) / (Max - Pass)) ^ (1/Exp)
    const gradeRange = config.gradeMax - passGrade;
    const ratio = Math.pow((targetRawGrade - passGrade) / gradeRange, 1 / exponent);
    return config.pointsFor4 + (ratio * (config.pointsFor6 - config.pointsFor4));
  }
};

export const calculateStats = (students: Student[]): Stats => {
  if (students.length === 0) {
    return { average: 0, median: 0, min: 0, max: 0, passRate: 0, stdDev: 0 };
  }

  const grades = students.map(s => s.grade).sort((a, b) => a - b);
  const sum = grades.reduce((acc, curr) => acc + curr, 0);
  const avg = sum / students.length;

  const mid = Math.floor(grades.length / 2);
  const median = grades.length % 2 !== 0 ? grades[mid] : (grades[mid - 1] + grades[mid]) / 2;

  const passing = students.filter(s => s.grade >= 4.0).length;
  
  const squareDiffs = grades.map(value => Math.pow(value - avg, 2));
  const avgSquareDiff = squareDiffs.reduce((a, b) => a + b, 0) / grades.length;
  const stdDev = Math.sqrt(avgSquareDiff);

  return {
    average: parseFloat(avg.toFixed(2)),
    median: parseFloat(median.toFixed(2)),
    min: grades[0],
    max: grades[grades.length - 1],
    passRate: parseFloat(((passing / students.length) * 100).toFixed(1)),
    stdDev: parseFloat(stdDev.toFixed(2))
  };
};

export const generateId = () => Math.random().toString(36).substr(2, 9);

export const parseCSV = (text: string): { name: string, points: number }[] => {
  const lines = text.split('\n');
  const results = [];
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    if (!line) continue;
    const parts = line.split(/[,;]/); 
    if (parts.length >= 2) {
      const name = parts[0].trim();
      const points = parseFloat(parts[1].trim());
      if (name && !isNaN(points)) {
        results.push({ name, points });
      }
    }
  }
  return results;
};

export const downloadCSV = (students: Student[]) => {
  const header = "Name,Points,Grade,Status\n";
  const rows = students.map(s => `"${s.name}",${s.points},${s.grade},${s.grade >= 4 ? 'Pass' : 'Fail'}`).join("\n");
  const blob = new Blob([header + rows], { type: 'text/csv' });
  const url = window.URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.setAttribute('hidden', '');
  a.setAttribute('href', url);
  a.setAttribute('download', 'grades.csv');
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
};